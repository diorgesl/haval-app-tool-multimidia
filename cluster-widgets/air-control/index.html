<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GWM App</title>
    <link rel="stylesheet" href="/src/night.style.css">
    <link rel="stylesheet" href="/src/main.menu.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-streaming@1.9.0/dist/chartjs-plugin-streaming.min.js"></script>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>


    <script type="module">
      // Importa o stateManager para podermos interagir com ele nos testes
      import { setState, stateManager } from './src/state.js';
      import { menuItems } from './src/components/mainMenu.js';

      console.log("✅ Ambiente de teste local (Live Server) carregado.");
      console.log("   - Setas (↑/↓/←/→) para navegar/ajustar.");
      console.log("   - 'Enter' para selecionar/alternar foco.");
      console.log("   - 'Backspace' para voltar ao menu.");

      // --- Definição das áreas focáveis em cada tela ---
      const focusableAreas = {
          main_menu: menuItems.map(item => item.id),
          ac_control: ['fan', 'temp'],
          regen: ['Normal', 'Media', 'Alta'],
          graph: ['evConsumption', 'gasConsumption', 'batteryPercentage']
      };

      // --- Simulação dos botões do volante usando o teclado ---
      document.addEventListener('keydown', (e) => {
          // Ignora teclas modificadoras para evitar comportamento inesperado
          if (e.ctrlKey || e.altKey || e.metaKey) return;

          // Pega o estado atual em cada pressionamento de tecla
          const currentState = stateManager.getState();
          const currentScreen = currentState.screen;

          // --- LÓGICA PARA VOLTAR (BACKSPACE) ---
          if (e.key === 'Backspace') {
              if (currentScreen !== 'main_menu') {
                  console.log("[AÇÃO] Voltando para o menu principal...");
                  window.showScreen('main_menu');
              }
              return; // Impede que o resto do código seja executado
          }

          // --- LÓGICA DE NAVEGAÇÃO DO MENU PRINCIPAL ---
          if (currentScreen === 'main_menu') {
              const menuItems = focusableAreas.main_menu;
              const currentIndex = menuItems.indexOf(currentState.focusedMenuItem);

              if (e.key === 'ArrowUp') {
                  const prevIndex = (currentIndex - 1 + menuItems.length) % menuItems.length;
                  window.focus(menuItems[prevIndex]);
              } else if (e.key === 'ArrowDown') {
                  const nextIndex = (currentIndex + 1) % menuItems.length;
                  window.focus(menuItems[nextIndex]);

          // Logica para seleção de items
              } else if (e.key === 'Enter') {
                  console.log(`[AÇÃO] 'Enter' pressionado no menu: ${currentState.focusedMenuItem}`);

                  if (currentState.focusedMenuItem === 'option_1') {
                      const currentStatus = stateManager.getState().espStatus;
                      const newStatus = (currentStatus === 'ON') ? 'OFF' : 'ON';
                      console.log(`[AÇÃO] Alterando ESP de '${currentStatus}' para '${newStatus}'`);
                      setState('espStatus', newStatus);
                  } else if (currentState.focusedMenuItem === 'option_2') {
                      const modes = ['HEV', 'PHEV', 'EV'];
                      const currentMode = stateManager.getState().evMode;
                      const currentIndex = modes.indexOf(currentMode);
                      const nextIndex = (currentIndex + 1) % modes.length;
                      const newMode = modes[nextIndex];
                      console.log(`[AÇÃO] Alterando Modo de '${currentMode}' para '${newMode}'`);
                      setState('evMode', newMode);
                  } else if (currentState.focusedMenuItem === 'option_3') {
                      const modes = ['Normal', 'Eco', 'Sport'];
                      const currentMode = stateManager.getState().drivingMode;
                      const currentIndex = modes.indexOf(currentMode);
                      const nextIndex = (currentIndex + 1) % modes.length;
                      const newMode = modes[nextIndex];
                      console.log(`[AÇÃO] Alterando Modo de '${currentMode}' para '${newMode}'`);
                      setState('drivingMode', newMode);
                  } else if (currentState.focusedMenuItem === 'option_4') {
                      window.showScreen('aircon');
                  } else if (currentState.focusedMenuItem === 'option_5') {
                      const modes = ['Normal', 'Conforto', 'Esportiva'];
                      const currentMode = stateManager.getState().steerMode;
                      const currentIndex = modes.indexOf(currentMode);
                      const nextIndex = (currentIndex + 1) % modes.length;
                      const newMode = modes[nextIndex];
                      console.log(`[AÇÃO] Alterando Modo de Direcao de '${currentMode}' para '${newMode}'`);
                      setState('steerMode', newMode);
                  } else if (currentState.focusedMenuItem === 'option_6') {
                      window.showScreen('regen');
                  } else if (currentState.focusedMenuItem === 'option_7') {
                      window.showScreen('graph');
                  }


              }
          }

          // --- LÓGICA DE CONTROLE DO AR CONDICIONADO ---
          else if (currentScreen === 'aircon') {
              const focusedArea = currentState.focusArea;

              if (e.key === 'Enter') {
                  // Alterna o foco entre as áreas de controle do AC
                  const controls = focusableAreas.ac_control;
                  const currentIndex = controls.indexOf(focusedArea);
                  const nextIndex = (currentIndex + 1) % controls.length;
                  console.log(`[AÇÃO] Alternando foco de '${focusedArea}' para '${controls[nextIndex]}'`);
                  window.focus(controls[nextIndex]);
              }

              // Lógica específica para a área focada atualmente
              switch (focusedArea) {
                  case 'fan':
                      const currentFan = parseInt(currentState.fan, 10) || 0;
                      if (e.key === 'ArrowUp' && currentFan < 7) {
                          window.control('fan', String(currentFan + 1));
                      } else if (e.key === 'ArrowDown' && currentFan > 0) {
                          window.control('fan', String(currentFan - 1));
                      }
                      break;

                  case 'temp':
                      const currentTemp = parseFloat(currentState.temp) || 21.0;
                      if (e.key === 'ArrowUp' && currentTemp < 26.0) {
                          window.control('temp', (currentTemp + 0.5).toFixed(1));
                      } else if (e.key === 'ArrowDown' && currentTemp > 16.0) {
                          window.control('temp', (currentTemp - 0.5).toFixed(1));
                      }
                      break;

                  case 'power':
                      // A tecla 'Enter' já alterna o foco, mas poderíamos adicionar
                      // uma ação específica aqui se o foco estivesse em 'power'
                      // Por exemplo, as setas poderiam ligar/desligar.
                      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                           const newPowerState = currentState.power === '0' ? '1' : '0';
                           window.control('power', newPowerState);
                      }
                      break;
              }
          }
          // --- LÓGICA DE CONTROLE DE REGENERACAO ---
          else if (currentScreen === 'regen') {
              const regenMode = currentState.regenMode;

              if (e.key === 'Enter') {
                  console.log(`[AÇÃO] Alternando foco de '${regenMode}' para 'Media'`);
                  window.control('regenMode', 'Media');
              } else if (e.key === 'ArrowUp') {
                  const controls = focusableAreas.regen;
                  const currentIndex = controls.indexOf(regenMode);
                  if (currentIndex < 2) {
                     const nextIndex = (currentIndex + 1) % controls.length;
                     console.log(`[AÇÃO] Alternando foco de '${regenMode}' para '${controls[nextIndex]}'`);
                     window.control('regenMode', controls[nextIndex]);
                  }
              } else if (e.key === 'ArrowDown') {
                  const controls = focusableAreas.regen;
                  const currentIndex = controls.indexOf(regenMode);
                  if (currentIndex > 0) {
                     const nextIndex = (currentIndex - 1) % controls.length;
                     console.log(`[AÇÃO] Alternando foco de '${regenMode}' para '${controls[nextIndex]}'`);
                     window.control('regenMode', controls[nextIndex]);
                  }
              }
          }
          // --- LÓGICA DE CONTROLE DE REGENERACAO ---
          else if (currentScreen === 'graph') {
              const currentGraph = currentState.currentGraph;

              if ((e.key === 'Enter') || (e.key === 'ArrowDown')) {
                  const controls = focusableAreas.graph;
                  const currentIndex = controls.indexOf(currentGraph);
                  if (currentIndex < 2) {
                     const nextIndex = (currentIndex + 1) % controls.length;
                     console.log(`[AÇÃO] Alternando foco de '${currentGraph}' para '${controls[nextIndex]}'`);
                     window.control('currentGraph', controls[nextIndex]);
                  }
              } else if (e.key === 'ArrowUp') {
                  const controls = focusableAreas.graph;
                  const currentIndex = controls.indexOf(currentGraph);
                  if (currentIndex > 0) {
                     const nextIndex = (currentIndex - 1) % controls.length;
                     console.log(`[AÇÃO] Alternando foco de '${currentGraph}' para '${controls[nextIndex]}'`);
                     window.control('currentGraph', controls[nextIndex]);
                  }
              }
          }
      });

      // --- SIMULAÇÃO DE DADOS DE CONSUMOEV EM TEMPO REAL ---
      setInterval(() => {
          // Random value from 1 to 100
          const randomValue = Math.floor(Math.random() * 101);

          setState('lastRegenValue', randomValue);
          setState('evConsumption', randomValue);

      }, 1000); // Executa a cada 1000ms (1 segundo)


    </script>
  </body>

</html>
