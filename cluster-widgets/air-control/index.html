<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GWM App</title>
    <link rel="stylesheet" href="/src/night.style.css">
    <link rel="stylesheet" href="/src/main.menu.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="app"></div>
    <script>
      function createElement(tagName, props = {}) {
          // Create the element
          const element = document.createElement(tagName);
          const children = props.children || [];

          // Handle props
          if (props) {
              // Handle className (convert to class)
              if (props.className) {
                  element.className = props.className;
                  delete props.className;
              }

              // Handle style object
              if (props.style && typeof props.style === 'object') {
                  Object.assign(element.style, props.style);
                  delete props.style;
              }

              // Handle event listeners (props starting with 'on')
              Object.keys(props).forEach(key => {
                  if (key.startsWith('on') && typeof props[key] === 'function') {
                      const eventName = key.slice(2).toLowerCase();
                      element.addEventListener(eventName, props[key]);
                      delete props[key];
                  }
              });

              // Handle other attributes
              Object.keys(props).forEach(key => {
                  if (props[key] !== undefined && props[key] !== null) {
                      element.setAttribute(key, props[key]);
                  }
              });
          }

          // Handle children
          children.forEach(child => {
              if (child === null || child === undefined) {
                  return;
              }

              if (typeof child === 'string' || typeof child === 'number') {
                  element.appendChild(document.createTextNode(child));
              } else if (child instanceof HTMLElement) {
                  element.appendChild(child);
              } else if (Array.isArray(child)) {
                  child.forEach(nestedChild => {
                      if (nestedChild !== null && nestedChild !== undefined) {
                          if (typeof nestedChild === 'string' || typeof nestedChild === 'number') {
                              element.appendChild(document.createTextNode(nestedChild));
                          } else if (nestedChild instanceof HTMLElement) {
                              element.appendChild(nestedChild);
                          }
                      }
                  });
              }
          });

          return element;
      }

      /**
       * Shorthand functions for common elements
       */
      const div = (props, ...children) => createElement('div', props, ...children);
      const span = (props, ...children) => createElement('span', props, ...children);
      const button = (props, ...children) => createElement('button', props, ...children);
      const img = (props) => createElement('img', props);
      const p = (props, ...children) => createElement('p', props, ...children);
      const h1 = (props, ...children) => createElement('h1', props, ...children);
      const h2 = (props, ...children) => createElement('h2', props, ...children);
      const h3 = (props, ...children) => createElement('h3', props, ...children);

      /**
       * Utility for creating elements with common patterns
       */
      const createElementWithClasses = (tagName, className, props = {}, ...children) => {
          return createElement(tagName, { ...props, className }, ...children);
      };

      /**
       * Utility for creating styled elements
       */
      const createStyledElement = (tagName, styles, props = {}, ...children) => {
          return createElement(tagName, { ...props, style: styles }, ...children);
      };

    </script>

    <script type="module" src="/src/main.js"></script>

    <!-- =================================================================== -->
    <!--   PASSO 1: SCRIPT DE SIMULAÇÃO MELHORADO (COLE ISTO NO SEU HTML)    -->
    <!-- =================================================================== -->
    <script type="module">
      // Importa o stateManager para podermos interagir com ele nos testes
      import { setState, stateManager } from './src/state.js';
      import { menuItems } from './src/components/mainMenu.js';

      console.log("✅ Ambiente de teste local (Live Server) carregado.");
      console.log("   - Setas (↑/↓/←/→) para navegar/ajustar.");
      console.log("   - 'Enter' para selecionar/alternar foco.");
      console.log("   - 'Backspace' para voltar ao menu.");

      // --- Definição das áreas focáveis em cada tela ---
      const focusableAreas = {
          main_menu: menuItems.map(item => item.id), // ['option_1', 'option_2', ...]
          ac_control: ['fan', 'temp', 'power'] // As áreas de controle do AC
      };

      // --- Simulação dos botões do volante usando o teclado ---
      document.addEventListener('keydown', (e) => {
          // Ignora teclas modificadoras para evitar comportamento inesperado
          if (e.ctrlKey || e.altKey || e.metaKey) return;

          // Pega o estado atual em cada pressionamento de tecla
          const currentState = stateManager.getState();
          const currentScreen = currentState.screen;

          // --- LÓGICA PARA VOLTAR (BACKSPACE) ---
          if (e.key === 'Backspace') {
              if (currentScreen !== 'main_menu') {
                  console.log("[AÇÃO] Voltando para o menu principal...");
                  window.showScreen('main_menu');
              }
              return; // Impede que o resto do código seja executado
          }

          // --- LÓGICA DE NAVEGAÇÃO DO MENU PRINCIPAL ---
          if (currentScreen === 'main_menu') {
              const menuItems = focusableAreas.main_menu;
              const currentIndex = menuItems.indexOf(currentState.focusedMenuItem);

              if (e.key === 'ArrowUp') {
                  const prevIndex = (currentIndex - 1 + menuItems.length) % menuItems.length;
                  window.focus(menuItems[prevIndex]);
              } else if (e.key === 'ArrowDown') {
                  const nextIndex = (currentIndex + 1) % menuItems.length;
                  window.focus(menuItems[nextIndex]);
              } else if (e.key === 'Enter') {
                  console.log(`[AÇÃO] 'Enter' pressionado no menu: ${currentState.focusedMenuItem}`);
                  // Apenas 'option_2' (Ar Condicionado) tem uma ação
                  if (currentState.focusedMenuItem === 'option_3') {
                      window.showScreen('ac_control');
                  }

                  if (currentState.focusedMenuItem === 'option_1') {
                      const currentStatus = stateManager.getState().espStatus;
                      const newStatus = (currentStatus === 'ON') ? 'OFF' : 'ON';
                      console.log(`[AÇÃO] Alterando ESP de '${currentStatus}' para '${newStatus}'`);
                      setState('espStatus', newStatus);
                  } else if (currentState.focusedMenuItem === 'option_2') {
                      const modes = ['HEV', 'PHEV', 'EV'];
                      const currentMode = stateManager.getState().evMode;
                      const currentIndex = modes.indexOf(currentMode);
                      const nextIndex = (currentIndex + 1) % modes.length;
                      const newMode = modes[nextIndex];
                      console.log(`[AÇÃO] Alterando Modo de '${currentMode}' para '${newMode}'`);
                      setState('evMode', newMode);
                  } else if (currentState.focusedMenuItem === 'option_4') {
                      const modes = ['Normal', 'Eco', 'Sport'];
                      const currentMode = stateManager.getState().drivingMode;
                      const currentIndex = modes.indexOf(currentMode);
                      const nextIndex = (currentIndex + 1) % modes.length;
                      const newMode = modes[nextIndex];
                      console.log(`[AÇÃO] Alterando Modo de '${currentMode}' para '${newMode}'`);
                      setState('drivingMode', newMode);
                  } else if (currentState.focusedMenuItem === 'option_5') {
                      const modes = ['Normal', 'Conforto', 'Esportiva'];
                      const currentMode = stateManager.getState().steerMode;
                      const currentIndex = modes.indexOf(currentMode);
                      const nextIndex = (currentIndex + 1) % modes.length;
                      const newMode = modes[nextIndex];
                      console.log(`[AÇÃO] Alterando Modo de Direcao de '${currentMode}' para '${newMode}'`);
                      setState('steerMode', newMode);
                  } else if (currentState.focusedMenuItem === 'option_6') {
                      const modes = ['Normal', 'Média', 'Alta'];
                      const currentMode = stateManager.getState().regenMode;
                      const currentIndex = modes.indexOf(currentMode);
                      const nextIndex = (currentIndex + 1) % modes.length;
                      const newMode = modes[nextIndex];
                      console.log(`[AÇÃO] Alterando Modo de Regeneracao '${currentMode}' para '${newMode}'`);
                      setState('regenMode', newMode);
                  }
              }
          }

          // --- LÓGICA DE CONTROLE DO AR CONDICIONADO ---
          else if (currentScreen === 'ac_control') {
              const focusedArea = currentState.focusArea;

              if (e.key === 'Enter') {
                  // Alterna o foco entre as áreas de controle do AC
                  const controls = focusableAreas.ac_control;
                  const currentIndex = controls.indexOf(focusedArea);
                  const nextIndex = (currentIndex + 1) % controls.length;
                  console.log(`[AÇÃO] Alternando foco de '${focusedArea}' para '${controls[nextIndex]}'`);
                  window.focus(controls[nextIndex]);
              }

              // Lógica específica para a área focada atualmente
              switch (focusedArea) {
                  case 'fan':
                      const currentFan = parseInt(currentState.fan, 10) || 0;
                      if (e.key === 'ArrowUp' && currentFan < 7) {
                          window.control('fan', String(currentFan + 1));
                      } else if (e.key === 'ArrowDown' && currentFan > 0) {
                          window.control('fan', String(currentFan - 1));
                      }
                      break;

                  case 'temp':
                      const currentTemp = parseFloat(currentState.temp) || 21.0;
                      if (e.key === 'ArrowUp' && currentTemp < 30.0) {
                          window.control('temp', (currentTemp + 0.5).toFixed(1));
                      } else if (e.key === 'ArrowDown' && currentTemp > 16.0) {
                          window.control('temp', (currentTemp - 0.5).toFixed(1));
                      }
                      break;

                  case 'power':
                      // A tecla 'Enter' já alterna o foco, mas poderíamos adicionar
                      // uma ação específica aqui se o foco estivesse em 'power'
                      // Por exemplo, as setas poderiam ligar/desligar.
                      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                           const newPowerState = currentState.power === '0' ? '1' : '0';
                           window.control('power', newPowerState);
                      }
                      break;
              }
          }
      });
    </script>

  </body>
</html>
